[
{
	"uri": "//localhost:1313/vi/",
	"title": "CDK cơ bản - 2",
	"tags": [],
	"description": "",
	"content": "CDK cơ bản - 2 Tổng quan Trước khi làm workshop về CDK này, bạn nên đi qua workshop về CDK cơ bản để hiểu các khái niệm cơ bản của CDK. Bạn cũng nên có một vài kiến thức cơ bản về API Gateway, Elastic Load Balancer, Elastic Container Service và Lambda.\nChúng ta sẽ tái sử dụng workspace đã tạo trong phần CDK cơ bản để thực hành bài lab này. CDK 2.27.0 sẽ được sử dụng. Sau khi hoàn thành bài lab này, bạn sẽ biết cách\nSử dụng CDK để khởi tạo một kiến trúc ứng dụng cơ bản sử dụng API Gateway, Elastic Load Balancer, Elastic Container Service, và Lambda. Tạo nested stack sử dụng CDK Kiến trúc tổng thể của hệ thống mà chúng ta sẽ xây dựng như sau:\nNội dung Giới thiệu Chuẩn bị API Gateway và ECS Lambda và S3 Nested stack Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trước khi làm workshop về CDK này, bạn nên đi qua workshop về CDK cơ bản để hiểu các khái niệm cơ bản của CDK. Bạn cũng nên có một vài kiến thức cơ bản về API Gateway, Elastic Load Balancer, Elastic Container Service và Lambda.\nChúng ta sẽ tái sử dụng workspace đã tạo trong phần CDK cơ bản để thực hành bài lab này. CDK 2.27.0 sẽ được sử dụng. Sau khi hoàn thành bài lab này, bạn sẽ biết cách\nSử dụng CDK để khởi tạo một kiến trúc ứng dụng cơ bản sử dụng API Gateway, Elastic Load Balancer, Elastic Container Service, và Lambda. Tạo nested stack sử dụng CDK Kiến trúc tổng thể của hệ thống mà chúng ta sẽ xây dựng như sau:\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequisite/2.1-createiamrole/",
	"title": "Tạo IAM Role",
	"tags": [],
	"description": "",
	"content": "Tạo IAM Role Truy cập giao diện AWS Management Console\nTìm IAM Chọn IAM Trong giao diện IAM\nChọn Roles Chọn Create role Trong giao diện Select trusted entity\nChọn AWS service Use case, chọn EC2 Chọn Next Trong giao diện Create role\nTìm policy AdministratorAccess Chọn policy AdministratorAccess Chọn Next Trong giao diện Role details\nRole name, nhập CDK-Role Chọn Create role Hoàn thành tạo role "
},
{
	"uri": "//localhost:1313/vi/5-nestedstack/5.1-nestedstack/",
	"title": "Tạo nested stack với CDK",
	"tags": [],
	"description": "",
	"content": "Tạo nested stack với CDK Trước hết, hãy tạo file cdk_workshop_02/main_stack.py để chứa root stack touch cdk_workshop_02/main_stack.py Khởi tạo nested stack cho ECS Fargate + Load balancer với file cdk_workshop_02/lb_fargate_stack.py from aws_cdk import ( NestedStack, aws_ecs as ecs, aws_ecs_patterns as ecsp, ) from constructs import Construct class LBFargateStack(NestedStack): def __init__(self, scope: Construct, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;LB Fargate Stack\u0026#34;, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) self.lb = lb_fargate_service.load_balancer Khởi tạo nested stack cho Lambda với file cdk_workshop_02/lambda_stack.py from aws_cdk import ( NestedStack, aws_s3 as s3, aws_lambda as lambda_ ) from constructs import Construct class LambdaStack(NestedStack): def __init__(self, scope: Construct, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;Lambda Stack\u0026#34;, **kwargs) # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_20_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict( BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) self.handler = handler Khởi tạo nested stack cho API Gateway với file cdk_workshop_02/api_gateway_stack.py from aws_cdk import ( NestedStack, aws_apigateway as apigateway, aws_ecs_patterns as ecsp, aws_lambda as lambda_ ) from constructs import Construct class APIGatewayStack(NestedStack): def __init__(self, scope: Construct, lb_dns: str, lambda_handler: lambda_.Function, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;API Gateway Stack\u0026#34;, **kwargs) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Add resource and method for ECS proxy request ecs_proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) ecs_proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) # Create Lambda intergration get_widgets_integration = apigateway.LambdaIntegration(lambda_handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;}) # Add resource and method for Lambda proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) self.url = api.url Lắp ráp lại vào file template gốc để tạo root stack với file cdk_workshop_02/main_stack.py from aws_cdk import ( Stack, aws_apigateway as apigateway, aws_s3 as s3, aws_lambda as lambda_, CfnOutput ) from constructs import Construct from .lambda_stack import LambdaStack from .lb_fargate_stack import LBFargateStack from .api_gateway_stack import APIGatewayStack class MainStack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) lb_fargate_stack = LBFargateStack(self) lambda_stack = LambdaStack(self) # Get the DNS value of the Application Load Balancer lb_dns = lb_fargate_stack.lb.load_balancer_dns_name api_gateway_stack = APIGatewayStack(self, lb_dns, lambda_stack.handler) # Define stack output CfnOutput(self, \u0026#34;API Gateway URL\u0026#34;, value=api_gateway_stack.url) Thay đổi code trong file app.py để sử dụng template chúng ta mới tạo #!/usr/bin/env python3 import os import aws_cdk as cdk from cdk_workshop_02.main_stack import MainStack app = cdk.App() # CdkWorkshop02Stack(app, \u0026#34;CdkWorkshop02Stack\u0026#34;) MainStack(app, \u0026#34;MainStack\u0026#34;) app.synth() Triển khai cdk bootstrap cdk deploy Sau khi triển khai xong, bạn có thể thấy các stack đã được tạo trong AWS CloudFormation Console\nBạn có thể thử API gateway URL cho Lambda và ECS như ở phần trước.\nLưu ý: Việc thay đổi code trong file app.py tương ứng với việc triển khai một CloudFormation template mới. Trong bài lab nâng cao này, mỗi CloudFormation stack cần 2 elastic IP để hoạt động. Khi triển khai một stack, nếu số lượng elastic IP vượt quá giới hạn của account (mặc định là 5), CloudFormation stack có thể không khởi tạo được và bị kẹt ở trạng thái IN_PROGRESS. Hãy đảm bảo bạn release hết các elastic IP không cần thiết khi làm bài lab này.\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequisite/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Phần chuẩn bị này giống với phần chuẩn bị ở workshop CDK cơ bản, vậy nên bạn có thể tái sử dụng các tài nguyên đã được tạo (IAM Role, Cloud9 Workspace) và chuyển đến phần tiếp theo.\nTạo IAM Role Tạo Cloud9 Workspace Cấu hình Cloud9 Workspace "
},
{
	"uri": "//localhost:1313/vi/2-prerequisite/2.2-createworkspace/",
	"title": "Tạo workspace",
	"tags": [],
	"description": "",
	"content": "Tạo workspace Truy cập vào giao diện AWS Management Console\nTìm Cloud9 Chọn Cloud9 Trong giao diện AWS Cloud9\nChọn Create environment Trong giao diện Create environment\nName, nhập ASG-Cloud9-Workshop Environment type, chọn New EC2 instance: EC2 Instance được khởi tạo cùng với Cloud9 environment. Instance được truy cập qua Cloud9 IDE sử dụng phương thức SSH. Instance type, chọn t3.small(2GiB RAM + 2vCPU) Platform, chọn Amazon Linux 2023 (Recommended) Timeout: sau 30’ nếu EC2 Instance không có tiến trình nào được chạy, Cloud9 sẽ stop Instance. Để tuỳ chọn Network theo như mặc định (default VPC) Chọn Create Giao diện môi trường vừa khởi tạo "
},
{
	"uri": "//localhost:1313/vi/2-prerequisite/2.3-setupcloud9/",
	"title": "Cấu hình Cloud9",
	"tags": [],
	"description": "",
	"content": "Cấu hình môi trường Cloud9 Trong giao diện môi trường vừa khởi tạo\nChọn biểu tượng user hình tròn ở góc phải màn hình, bên cạnh Share Chọn Manage EC2 Instance Trong giao diện EC2 Chọn Cloud9 Instance. Chọn Action Chọn Security Chọn Modify IAM role Trong giao diện Modify IAM role\nChọn role đã tạo, bài lab này chọn CDK-Role Chọn Update IAM role Hoàn thành gán role thành công. Trong giao diện của môi trường AWS Cloud9\nChọn Icon của Cloud9 Chọn Preferences Cloud9 sẽ quản lý thông tin chứng thực IAM một cách tự động. Chúng ta sẽ cần phải vô hiệu hóa tính năng này và sử dụng IAM Role.\nChọn AWS SETTINGS Bỏ chọn AWS managed temporary credentials Copy và Paste đoạn lệnh dưới đây vào Terminal của Cloud9 Workspace để cài đặt các công cụ hỗ trợ xử lý text trên dòng lệnh. sudo yum -y install jq gettext bash-completion Tương tự như CloudFormation, bạn có thể thực hiện cài đặt tool cfn-lint để giúp bạn kiểm tra CDK templates và các thông tin khác, bao gồm kiểm tra các thuộc tính của tài nguyên đã chính xác hay chưa hoặc thông tin cấu hình đã theo best practices hay chưa. pip install cfn-lint Kiểm tra cài đặt cfn-lint thành công bằng cách dùng lệnh sau: cfn-lint --version Chúng ta sẽ cấu hình aws cli sử dụng Region hiện tại. export ACCOUNT_ID=\u0026lt;Your Account ID\u0026gt;\rexport AWS_REGION=\u0026lt;Your AWS Region\u0026gt;\rexport AZS=($(aws ec2 describe-availability-zones --query \u0026#39;AvailabilityZones[].ZoneName\u0026#39; --output text --region $AWS_REGION)) Chúng ta sẽ lưu các thông tin cấu hình vào bash_profile echo \u0026#34;export ACCOUNT_ID=${ACCOUNT_ID}\u0026#34; | tee -a ~/.bash_profile echo \u0026#34;export AWS_REGION=${AWS_REGION}\u0026#34; | tee -a ~/.bash_profile echo \u0026#34;export AZS=(${AZS[@]})\u0026#34; | tee -a ~/.bash_profile aws configure set default.region ${AWS_REGION} Kiểm tra xem CLI CDK đã được cài đặt chưa bằng cách chạy lệnh. cdk --version Chúng ta sẽ sử dụng câu lệnh để kiểm tra Cloud9 IDE đang sử dụng IAM Role có chính xác không. aws sts get-caller-identity --query Arn | grep CDK-Role -q \u0026amp;\u0026amp; echo \u0026#34;IAM role valid\u0026#34; || echo \u0026#34;IAM role NOT valid\u0026#34; "
},
{
	"uri": "//localhost:1313/vi/3-apigatewayandecs/",
	"title": "ECS, ALB và API Gateway",
	"tags": [],
	"description": "",
	"content": "Tạo cụm ECS và Application Load Balancer Truy cập vào workspace Cloud9 đã tạo Tạo một thư mục mới có tên cdk-workshop-02 Khởi tạo project CDK\ncd ~/environment/cdk-workshop-02 cdk init --language python Import các thư viện cần thiết trong file cdk-workshop-02/cdk_workshop_02_stack.py from aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway ) from constructs import Construct Trong file cdk-workshop-02/cdk_workshop_02_stack.py, khai báo một dịch vụ ECS kết hợp với Application Load Balancer trong hàm __init__() # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;) ), public_load_balancer=True, desired_count=3 ) ecsp.ApplicationLoadBalancedFargateService sẽ khởi tạo các resource sau:\nMột VPC mới với các cấu hình (subnet, Internet Gateway, RouteTable, EIP, Nat Gateway, …) được khởi tạo theo tuỳ chọn mặc định. Một ECS cluster nằm trong VPC mới được tạo, với chế độ chạy sử dụng Fargate Một ECS Task được định nghĩa bằng image nginxdemos/hello từ Dockerhub Một nhóm ECS container được chạy từ ECS Task vừa tạo, với số instance là 3 Một Application Load Balancer nằm trước cụm ECS vừa tạo Các Role và Security Group cần thiết Cấu hình API Gateway Khai báo API Gateway # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) Cấu hình API Gateway resource để trỏ đến DNS của Application Load Balancer # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) Bạn có thể đọc thêm về các phương thức và thuộc tính của ApplicationLoadBalancedFargateService tại tài liệu chính thức về CDK của AWS (Python)\nKiểm tra lại code tại cdk-workshop-02/cdk_workshop_02_stack.py from aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway ) from constructs import Construct class CdkWorkshop02Stack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) Triển khai Kiểm tra các resource sẽ tạo bằng việc chạy lệnh pip install aws-cdk.aws-lambda-python-alpha cdk diff Triển khai stack cdk bootstrap\rcdk deploy Chọn y để tiếp tục\nHoàn thành Truy cập vào đường link của API gateway (ProxyToLBECSEndpoint), thêm path /ecs. Bạn sẽ truy cập được vào web server được triển khai trong ECS.\nĐể kiểm tra sự hoạt động của Application Load Balancer, nhấn refresh một vài lần, bạn sẽ thấy đích đến của trang web thay đổi. Ở phần trước, chúng ta đặt tham số desired_count=3, nên sẽ có 3 container được triển khai song song với nhau đằng sau ALB. Bạn sẽ thấy sự thay đổi ở Server address qua các lần refresh.\nNếu bạn đã chạy được đến phần này, chúc mừng bạn đã hoàn thành phần đầu tiên của bài lab CDK nâng cao. Ở phần tiếp theo, chúng ta sẽ sử dụng CDK để triển khai một hàm Lambda đằng sau 1 resource của API Gateway.\n"
},
{
	"uri": "//localhost:1313/vi/4-lambdaands3/",
	"title": "Lambda và S3",
	"tags": [],
	"description": "",
	"content": "Lambda và S3 Ở phần này, chúng ta sẽ cùng nhau cấu hình một hàm Lambda và kết hợp với API Gateway. Ta sẽ tái sử dụng template ở phần trước (API Gateway và ECS)\nTạo thư mục resources ở thư mục gốc của project mkdir resources Tạo file widget.js trong thư mục resources /* This code uses callbacks to handle asynchronous function responses. It currently demonstrates using an async-await pattern. AWS supports both the async-await and promises patterns. For more information, see the following: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/calling-services-asynchronously.html https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html */ const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3(); const bucketName = process.env.BUCKET; exports.main = async function(event, context) { try { var method = event.httpMethod; const data = await S3.listObjectsV2({ Bucket: bucketName }).promise(); var body = { widgets: data.Contents.map(function(e) { return e.Key }) }; return { statusCode: 200, headers: {}, body: JSON.stringify(body) }; } catch(error) { var body = error.stack || JSON.stringify(error, null, 2); return { statusCode: 400, headers: {}, body: JSON.stringify(body) } } } Hàm lambda này sẽ trả về danh sách các object có trong S3 bucket.\nTrong cdk_workshop_02/cdk_workshop_02_stack.py khởi tạo S3 bucket # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) Tạo lambda function và gán quyền tương ứng với S3 bucket vừa tạo # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_14_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict(BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) Tạo intergration cho API Gateway # Create intergration get_widgets_integration = apigateway.LambdaIntegration( handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;} ) Thêm resource và method tương ứng cho API Gateway # Add resource and method for proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) Đừng quên import thêm các thư viện cần thiết để sử dụng được Lambda, API Gateway và S3. Sau khi import xong, hãy kiểm tra lại nội dung file cdk_workshop_02/cdk_workshop_02_stack.py của bạn\nfrom aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway, aws_s3 as s3, aws_lambda as lambda_ ) from constructs import Construct class CdkWorkshop02Stack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_20_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict(BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) # Create intergration get_widgets_integration = apigateway.LambdaIntegration( handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;} ) # Add resource and method for proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) Triển khai stack cdk deploy Hoàn thành Truy cập vào đường link của API gateway, thêm path /lambda. Bạn sẽ thấy kết quả trả về từ hàm lambda.\nĐể kiểm tra, hãy truy cập vào S3 Console. Truy cập vào bucket được tạo và upload một file bất kỳ\nTruy cập lại vào đường dẫn đến hàm lambda xxxxxxx.execute-api.[REGION].amazonaws.com/prod/lambda của API Gateway. Bạn sẽ thấy tên file mới được hiển thị. Nếu bạn đã chạy được đến phần này, chúc mừng bạn đã hoàn thành phần thứ hai của bài lab CDK nâng cao. Ở phần tiếp theo, chúng ta sẽ refractor lại project bằng cách tách nhỏ các thành phần trong file cdk_workshop_02/cdk_workshop_02_stack.py thành các file khác nhau, và sử dụng nested stack để triển khai kiến trúc hệ thống của chúng ta.\n"
},
{
	"uri": "//localhost:1313/vi/5-nestedstack/",
	"title": "Nested Stack",
	"tags": [],
	"description": "",
	"content": "Nested Stack Việc triển khai một kiến trúc lớn trong 1 file là không hợp lý. Bởi CDK hoạt động dựa trên CloudFormation, chúng ta hoàn toàn có thể vận dụng nested stack để chia nhỏ stack tổng thể ra làm nhiều stack nhỏ khác nhau, giúp thuận lợi cho việc quản lý các tài nguyên.\nTrong phần cuối cùng của bài lab CDK nâng cao này, chúng ta sẽ chia nhỏ template được tạo ra ở phần trước thành các template nhỏ hơn với trách nhiệm riêng biệt. Cụ thể, chúng ta sẽ chia thành 3 template:\nECS và ALB Lambda và S3 API Gateway "
},
{
	"uri": "//localhost:1313/vi/6-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Tương tự như phần CDK cơ bản, bạn có thể dọn dẹp hết các tài nguyên đã tạo để tránh bị charge phí không đáng có. Để xoá các tài nguyên trong stack, chạy lệnh\ncdk destroy Ngoài ra, với dịch vụ S3 bucket, nếu bạn đã upload file vào bucket, nó sẽ không thể bị xoá bởi lệnh cdk destroy, bạn sẽ cần xoá hết toàn bộ các file có trong bucket, và sau đó xoá bucket.\nChúc mừng bạn đã hoàn thành bài lab CDK nâng cao!\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]