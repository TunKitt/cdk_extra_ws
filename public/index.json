[
{
	"uri": "//localhost:1313/",
	"title": "CDK Basic - 2 ",
	"tags": [],
	"description": "",
	"content": "CDK Basic - 2 Overview It is recommended that before doing the CDK Basic 2 Workshop, you should go through the CDK Basic Workshop to learn about CDK. You should have a little bit of knowledge about API Gateway, Elastic Load Balancer, Elastic Container Service, and Lambda.\nWe will reuse the workspace that has been created in the CDK Basic part to perform this workshop. CDK 2.27.0 would be used. After finishing this lab, you will know how to\nUse CDK to create a basic application architecture using API Gateway, Elastic Load Balancer, Elastic Container Service, and Lambda. Create nested stack using CDKHere is the architecture that we would build: Here is the architecture that we would build:\nContent Introduction Preparation API Gateway and ECS Lambda and S3 Nested stack Clean up "
},
{
	"uri": "//localhost:1313/2-prerequisite/2.1-createiamrole/",
	"title": "Create IAM Role",
	"tags": [],
	"description": "",
	"content": "Create IAM Role Access the AWS Management Console\nFind IAM Select IAM In the IAM interface\nSelect Roles Select Create role In the Select trusted entity interface\nSelect AWS service Use case, select EC2 Select Next In the Create role interface\nFind the policy AdministratorAccess Select the policy AdministratorAccess Select Next In the Role details interface\nRole name, enter CDK-Role Select Create role Complete role creation "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Overview It is recommended that before doing the CDK Basic 2 Workshop, you should go through the CDK Basic Workshop to learn about CDK. You should have a little bit of knowledge about API Gateway, Elastic Load Balancer, Elastic Container Service, and Lambda.\nWe will reuse the workspace that has been created in the CDK Basic part to perform this workshop. CDK 2.27.0 would be used. After finishing this lab, you will know how to\nUse CDK to create a basic application architecture using API Gateway, Elastic Load Balancer, Elastic Container Service, and Lambda. Create nested stack using CDKHere is the architecture that we would build: Here is the architecture that we would build:\n"
},
{
	"uri": "//localhost:1313/5-nestedstack/5.1-nestedstack/",
	"title": "Tạo nested stack với CDK",
	"tags": [],
	"description": "",
	"content": "Create nested stacks with CDK Firstly, create a cdk_workshop_02/main_stack.py file for the root stack. touch cdk_workshop_02/main_stack.py Declare a nested stack for ECS Fargate + Application Load Balancer with the file cdk_workshop_02/lb_fargate_stack.py from aws_cdk import ( NestedStack, aws_ecs as ecs, aws_ecs_patterns as ecsp, ) from constructs import Construct class LBFargateStack(NestedStack): def __init__(self, scope: Construct, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;LB Fargate Stack\u0026#34;, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) self.lb = lb_fargate_service.load_balancer Create a nested stack for Lambda in cdk_workshop_02/lambda_stack.py from aws_cdk import ( NestedStack, aws_s3 as s3, aws_lambda as lambda_ ) from constructs import Construct class LambdaStack(NestedStack): def __init__(self, scope: Construct, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;Lambda Stack\u0026#34;, **kwargs) # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_20_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict( BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) self.handler = handler Create a nested stack for API Gateway at cdk_workshop_02/api_gateway_stack.py from aws_cdk import ( NestedStack, aws_apigateway as apigateway, aws_ecs_patterns as ecsp, aws_lambda as lambda_ ) from constructs import Construct class APIGatewayStack(NestedStack): def __init__(self, scope: Construct, lb_dns: str, lambda_handler: lambda_.Function, **kwargs) -\u0026gt; None: super().__init__(scope, \u0026#34;API Gateway Stack\u0026#34;, **kwargs) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Add resource and method for ECS proxy request ecs_proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) ecs_proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) # Create Lambda intergration get_widgets_integration = apigateway.LambdaIntegration(lambda_handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;}) # Add resource and method for Lambda proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) self.url = api.url Put everything together in the root stack at cdk_workshop_02/main_stack.py from aws_cdk import ( Stack, aws_apigateway as apigateway, aws_s3 as s3, aws_lambda as lambda_, CfnOutput ) from constructs import Construct from .lambda_stack import LambdaStack from .lb_fargate_stack import LBFargateStack from .api_gateway_stack import APIGatewayStack class MainStack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) lb_fargate_stack = LBFargateStack(self) lambda_stack = LambdaStack(self) # Get the DNS value of the Application Load Balancer lb_dns = lb_fargate_stack.lb.load_balancer_dns_name api_gateway_stack = APIGatewayStack(self, lb_dns, lambda_stack.handler) # Define stack output CfnOutput(self, \u0026#34;API Gateway URL\u0026#34;, value=api_gateway_stack.url) Change the code in app.py to use our new template #!/usr/bin/env python3 import os import aws_cdk as cdk from cdk_workshop_02.main_stack import MainStack app = cdk.App() # CdkWorkshop02Stack(app, \u0026#34;CdkWorkshop02Stack\u0026#34;) MainStack(app, \u0026#34;MainStack\u0026#34;) app.synth() Deploy cdk bootstrap cdk deploy After deploying successfully, you can see the newly created stacks in the AWS CloudFormation Console.\nYou can try the API Gateway endpoint for Lambda and ECS like in the previous section.\nNote: Changing the code inside the app.py file will create a new CloudFormation template. In this advance workshop, each cloudformation stack needs 2 elastic IPs to function properly. When deploying a stack, if the number of Elastic IPs exceeds the limitation of your account (default is 5), the CloudFormation stack may not initiate and get stuck at the IN_PROGRESS state. Make sure that you release all the unneeded Elastic IPs when performing this workshop.\n"
},
{
	"uri": "//localhost:1313/2-prerequisite/2.2-createworkspace/",
	"title": "Create workspace",
	"tags": [],
	"description": "",
	"content": "Create workspace Access the AWS Management Console\nFind Cloud9 Select Cloud9 In the AWS Cloud9 interface\nSelect Create environment In the Create environment interface\nName, enter ASG-Cloud9-Workshop Environment type, select New EC2 instance: EC2 Instance is initialized with the Cloud9 environment. The instance is accessed via Cloud9 IDE using the SSH method. Instance type, select t3.small(2GiB RAM + 2vCPU) Platform, select Amazon Linux 2 (recommended) Timeout: after 30 minutes if EC2 Instance has no processes running, Cloud9 will stop Instance. Leave the Network option as default (default VPC) Select Create Environment interface just initialized "
},
{
	"uri": "//localhost:1313/2-prerequisite/",
	"title": "Preparation",
	"tags": [],
	"description": "",
	"content": "Preparation steps The preparation steps are similar to CDK Basic Workshop, you can reuse the resources that have been created (IAM Role, Cloud9 Workshop) and move to the next part.\nCreate IAM Role Create Cloud9 Workspace Configure Cloud9 Workspace "
},
{
	"uri": "//localhost:1313/2-prerequisite/2.3-setupcloud9/",
	"title": "Configure Cloud9 environment",
	"tags": [],
	"description": "",
	"content": "Configure Cloud9 environment In the environment interface just initialized\nSelect the circular user icon in the right corner of the screen, next to Share Select Manage EC2 Instance In the EC2 interface\nSelect Action Select Security Select Modify IAM role In the Modify IAM role interface\nSelect the created role, this lab choose CDK-Role Select Update IAM role Completed the role assignment successfully. In the view of the AWS Cloud9 environment\nSelect Icon Cloud9 Select Preferences Cloud9 will manage IAM credentials automatically. We will need to disable this feature and use the IAM Role.\nSelect AWS SETTINGS Uncheck AWS managed temporary credentials Copy and Paste the command below into the Terminal of Cloud9 Workspace to install tools to support text processing on the command line. sudo yum -y install jq gettext bash-completion Similar to CloudFormation, you can install the cfn-lint tool to help you check CDK templates and other information, including auditing. Check if the resource properties are correct or not configured according to best practices or not. pip install cfn-lint Check the successful installation of cfn-lint using the following command: cfn-lint --version We will configure the aws cli to use the current Region. export ACCOUNT_ID=\u0026lt;Your Account ID\u0026gt;\rexport AWS_REGION=\u0026lt;Your AWS Region\u0026gt;\rexport AZS=($(aws ec2 describe-availability-zones --query \u0026#39;AvailabilityZones[].ZoneName\u0026#39; --output text --region $AWS_REGION)) We will save the configuration information to bash_profile echo \u0026#34;export ACCOUNT_ID=${ACCOUNT_ID}\u0026#34; | tee -a ~/.bash_profile\recho \u0026#34;export AWS_REGION=${AWS_REGION}\u0026#34; | tee -a ~/.bash_profile\recho \u0026#34;export AZS=(${AZS[@]})\u0026#34; | tee -a ~/.bash_profile\raws configure set default.region ${AWS_REGION} Check if CLI CDK is installed by running the command. cdk --version We will use the command to check if the Cloud9 IDE is using the IAM Role correctly. aws sts get-caller-identity --query Arn | grep CDK-Role -q \u0026amp;\u0026amp; echo \u0026#34;IAM role valid\u0026#34; || echo \u0026#34;IAM role NOT valid\u0026#34; "
},
{
	"uri": "//localhost:1313/3-apigatewayandecs/",
	"title": "ECS, ALB and API Gateway",
	"tags": [],
	"description": "",
	"content": "Create ECS Cluster and Application Load Balancer Access the Cloud9 Workspace Create a new directory named cdk-workshop-02 Create CDK project\ncd ~/environment/cdk-workshop-02 cdk init --language python Import libraries in file cdk-workshop-02/cdk_workshop_02_stack.py from aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway ) from constructs import Construct In cdk-workshop-02/cdk_workshop_02_stack.py, declare a ECS cluster together with Application Load Balancer in the __init__() function # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;) ), public_load_balancer=True, desired_count=3 ) ecsp.ApplicationLoadBalancedFargateService will create the following resources:\nA new VPC with default configuration (subnet, Internet Gateway, RouteTable, EIP, Nat Gateway, …) A ECS cluster in the newly created VPC, running on Fargate An ECS Task defined by the nginxdemos/hello image from Dockerhub A ECS container group initiated from the ECS Task, with the number of instances is 3 A Application Load Balancer fronting the ECS cluster Needed roles and security groups Configure API Gateway Declare an API Gateway # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) Configure API Gateway resource to point to the DNS of the Application Load Balancer # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) You can read more about the methods and properties of ApplicationLoadBalancedFargateService at the official CDK documentation of AWS (Python)\nCheck the code in cdk-workshop-02/cdk_workshop_02_stack.py from aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway ) from constructs import Construct class CdkWorkshop02Stack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) Deploy Verify the resources that would be created by running pip install aws-cdk.aws-lambda-python-alpha cdk diff Deploy the stack cdk bootstrap\rcdk deploy Choose y to continue\nFinish Access the link to the API Gateway (ProxyToLBECSEndpoint), add the path /ecs. You will be able to access the webserver deployed in ECS.\nTo verify that the ALB works properly, hit refresh a couple of times, and you will see the target of the website change. In the previous section, we set the parameter desired_count=3, so there will be 3 containers being deployed in parallel behind the ALB. You will notice the change in the field Server address between the refreshes.\nIf you have reached this state, congratulations on finishing the first part of the CDK Advance Workshop. In the next section, we will use CDK to deploy a Lambda function behind an API Gateway resource.\n"
},
{
	"uri": "//localhost:1313/4-lambdaands3/",
	"title": "Lambda and S3",
	"tags": [],
	"description": "",
	"content": "Lambda and S3 In this section, we will configure a Lambda function with API Gateway. We will reuse the template of the previous section (API Gateway and ECS)\nCreate the resources directory at the project root mkdir resources Create the widget.js file in the resources directory /* This code uses callbacks to handle asynchronous function responses. It currently demonstrates using an async-await pattern. AWS supports both the async-await and promises patterns. For more information, see the following: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/calling-services-asynchronously.html https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html */ const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3(); const bucketName = process.env.BUCKET; exports.main = async function(event, context) { try { var method = event.httpMethod; const data = await S3.listObjectsV2({ Bucket: bucketName }).promise(); var body = { widgets: data.Contents.map(function(e) { return e.Key }) }; return { statusCode: 200, headers: {}, body: JSON.stringify(body) }; } catch(error) { var body = error.stack || JSON.stringify(error, null, 2); return { statusCode: 400, headers: {}, body: JSON.stringify(body) } } } This lambda function will return the list of objects in a S3 bucket.\nIn cdk_workshop_02/cdk_workshop_02_stack.py, declare a S3 bucket # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) Create the lambda function and grant the S3 bucket read and write permissions # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_14_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict(BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) Create an API Gateway intergration # Create intergration get_widgets_integration = apigateway.LambdaIntegration( handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;} ) Add a new resource and a new method to the API Gateway # Add resource and method for proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) Don\u0026rsquo;t forget to import the needed libraries to use Lambda, API Gateway and S3. After importing, recheck your cdk_workshop_02/cdk_workshop_02_stack.py file.\nfrom aws_cdk import ( Stack, aws_ecs as ecs, aws_ecs_patterns as ecsp, aws_apigateway as apigateway, aws_s3 as s3, aws_lambda as lambda_ ) from constructs import Construct class CdkWorkshop02Stack(Stack): def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u0026gt; None: super().__init__(scope, construct_id, **kwargs) # Declare a Load Balancer Fargate lb_fargate_service = ecsp.ApplicationLoadBalancedFargateService( self, \u0026#34;Workshop02-MyWebServer\u0026#34;, task_image_options=ecsp.ApplicationLoadBalancedTaskImageOptions( image=ecs.ContainerImage.from_registry(\u0026#34;nginxdemos/hello\u0026#34;)), public_load_balancer=True, desired_count=3 ) # Define API Gateway api = apigateway.RestApi(self, \u0026#34;ProxyToLBECS\u0026#34;) # Get the DNS value of the Application Load Balancer lb = lb_fargate_service.load_balancer lb_dns = lb_fargate_service.load_balancer.load_balancer_dns_name # Add resource and method for proxy request proxy = api.root.add_resource(\u0026#34;ecs\u0026#34;) proxy.add_method(\u0026#34;GET\u0026#34;, apigateway.HttpIntegration(f\u0026#34;http://{lb_dns}\u0026#34;)) # Add S3 bucket bucket = s3.Bucket(self, \u0026#34;WidgetStore\u0026#34;) # Add Lambda function handler = lambda_.Function(self, \u0026#34;WidgetHandler\u0026#34;, runtime=lambda_.Runtime.NODEJS_20_X, code=lambda_.Code.from_asset(\u0026#34;resources\u0026#34;), handler=\u0026#34;widget.main\u0026#34;, environment=dict(BUCKET=bucket.bucket_name) ) # Grant bucket permission to lambda function bucket.grant_read_write(handler) # Create intergration get_widgets_integration = apigateway.LambdaIntegration( handler, request_templates={\u0026#34;application/json\u0026#34;: \u0026#39;{ \u0026#34;statusCode\u0026#34;: \u0026#34;200\u0026#34; }\u0026#39;} ) # Add resource and method for proxy request lambda_proxy = api.root.add_resource(\u0026#34;lambda\u0026#34;) lambda_proxy.add_method(\u0026#34;GET\u0026#34;, get_widgets_integration) Deploy the stack cdk deploy Finish Access the API Gateway endpoint, and add the path /labmda. You will see the result returned from the Lambda function.\nTo verify that the Lambda function is working properly, access the S3 Console. Access the newly created bucket and upload a random file.\nAccess the endponit to the Lambda function xxxxxxx.execute-api.[REGION].amazonaws.com/prod/lambda of the API Gateway. You will see the new file name being displayed.\nIf you have reached this part, congratulations on finishing the second part of the CDK Advance Workshop. In the next section, we will refractor the project by splitting the components in the file cdk_workshop_02/cdk_workshop_02_stack.py into different files, and use nested stack to deploy the architecture.\n"
},
{
	"uri": "//localhost:1313/5-nestedstack/",
	"title": "Nested Stack",
	"tags": [],
	"description": "",
	"content": "Nested Stack It is infeasible to deploy a large architecture in a single file. Since CDK works on CloudFormation, we can utilize nested stacks to split our big stack into different smaller, easier to manage sub stacks.\nIn this last section of the CDK Advance Workshop, we will split the template in the previous part into smaller templates with separate responsibilities. In particular, we will split it into 3 templates:\nECS and ALB Lambda and S3 API Gateway "
},
{
	"uri": "//localhost:1313/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Clean up resources Similar to the CDK Basic Workshop, you can clean up all the resources in order to avoid unwanted charges. To delete all the resources in the stack, run the command\ncdk destroy If you have uploaded files into the bucket, it cannot be destroyed by the cdk destroy command. You will need to manually delete all the files inside the bucket, and then delete the bucket.\nCongratulations on finishing the CDK Advance Workshop!\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]